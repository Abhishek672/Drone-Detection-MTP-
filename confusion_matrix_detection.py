# -*- coding: utf-8 -*-
"""Confusion_matrix_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tu57N1zSYJ8beJytVUS2DD1Mc7OgIl9g
"""

import numpy as np
from PIL import Image
import imgaug as ia
from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage

def box_iou_calc(boxes1, boxes2):
    # https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py
    """
    Return intersection-over-union (Jaccard index) of boxes.
    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
    Arguments:
        boxes1 (Array[N, 4])
        boxes2 (Array[M, 4])
    Returns:
        iou (Array[N, M]): the NxM matrix containing the pairwise
            IoU values for every element in boxes1 and boxes2
    This implementation is taken from the above link and changed so that it only uses numpy.
    """

    def box_area(box):
        # box = 4xn
        return (box[2] - box[0]) * (box[3] - box[1])
    

    area1 = box_area(boxes1.T)
    area2 = box_area(boxes2.T)

    #left top coordinate of the intersecting bounding box...
    lt = np.maximum(boxes1[:, None, :2], boxes2[:, :2])  # [N,M,2]

    #right bottom coordinate of the intersecting bounding box..
    rb = np.minimum(boxes1[:, None, 2:], boxes2[:, 2:])  # [N,M,2]

    #area of intersection..
    inter = np.prod(np.clip(rb - lt, a_min = 0, a_max = None), 2)

    #IOU between every pair of bounding boxes..
    return inter / (area1[:, None] + area2 - inter)  # iou = inter / (area1 + area2 - inter)


def Confusion_Matrix(labels, detections, num_classes=1, CONFD_THRESHOLD = 0.3, IOU_THRESHOLD = 0.5):
  """
  currently implemented for 1 class only

  num_classes - number of classes @Integer

  CONFD_THRESHOLD - If an object is detected with confidence < CONF_THRESHOLD it will not be considered
             as detection. @float {default : 0.3}
  
  IOU_THRESHOLD - Intersection over Union threshold. Will be useful for classifying a detection
           as True Positive or False Positive @float
  
  labels - Array[N x ? x 5] numpy array. Ground truth bounding boxes for validation images
                 {class_id, x_min, y_min, x_max, y_max}

  detections - Array[N x ? x 6] numpy array. Detected bounding boxes for validation images
                 {xmin, ymin, xmax, ymax, confidence_threshold, class_id}

  return value - returns confusion matrix as 2D array
   
  """

  #Initialize Confusion matrix
  ##rows are ground truth columns are detected
  matrix = np.zeros((num_classes + 1, num_classes + 1))

  '''process for each image one by one'''
  num_images = labels.shape[0]

  for index in range(num_images):

    label_index = labels[index]
    detection_index = detections[index]   

    #If there are no ground truth bounding boxes but detected bounding boxes, they are FP
    if label_index.size == 0 and detection_index.size != 0:
      matrix[1][0]+=detection_index.shape[0] 
      continue
    
    #If there are  ground truth bounding boxes but no  detected bounding boxes, they are FN
    if label_index.size != 0 and detection_index.size == 0:
      matrix[0][1]+=label_index.shape[0] 
      continue 

    #If there are no ground truth bounding boxes and also no detected bounding boxes then do nothing
    if label_index.size == 0 and detection_index.size == 0:
      continue

    #If there are some ground truth and predicted bounding boxes
    #only consider detections that are > CONF_THRESHOLD confidence..
    detection_index = detection_index[detection_index[:, 4] > CONFD_THRESHOLD]

    #get the classes of each ground truth bbox
    gt_classes = label_index[:, 0].astype(np.int16)
    #get the predicted classes of each bboxes.
    detection_classes = detection_index[:, 5].astype(np.int16)

    #get pairwise iou between every pair of bounding box..
    all_ious = box_iou_calc(label_index[:, 1:], detection_index[:, :4])
    #filtering on the basis of IOU threshold..
    #want_idx = (arri , arrj) arri contains the row coordinates and arrj contains the column cordinates
    #for the cells that have IOU > IOU_THRESHOLD.
    want_idx = np.where(all_ious > IOU_THRESHOLD)

    #all_matches contain [[i1,j1,iou1],[i2,j2,iou2],[]] 
    all_matches = []
    for i in range(want_idx[0].shape[0]):
      all_matches.append([want_idx[0][i], want_idx[1][i], all_ious[want_idx[0][i], want_idx[1][i]]])
        
    all_matches = np.array(all_matches)

    #if there is at least 1 match based on iou.
    if all_matches.shape[0] > 0:

      #sort the matches according to iou values in descending order..
      all_matches = all_matches[all_matches[:, 2].argsort()[::-1]]

      #remove duplicate matchings (b1 -- b2) and (b3 -- b2) i.e. non max suppression
      #b1 matching with b2 and b3 is also matching with b2 
      #so we choose the one with max IOU value and we suppress the non max.
      all_matches = all_matches[np.unique(all_matches[:, 1], return_index = True)[1]]

      all_matches = all_matches[all_matches[:, 2].argsort()[::-1]]
      #remove duplicates - (b5 -- b10)(0.8) (b5 -- b7)(0.6)
      #select only the (b5 -- b10)with iou as 0.8 
      all_matches = all_matches[np.unique(all_matches[:, 0], return_index = True)[1]]
        
    #if there are no match acc to IOU Threshold..
    #FN = #gt bboxes..
    #FP = #detected bboxes..
    else :
      matrix[0][1]+=label_index.shape[0]
      matrix[1][0]+=detection_index.shape[0]
      continue

    #if there are some match based on iou
    #enumerate for all ground truth bounding boxes..
    for i, label in enumerate(label_index):
      #for each gt bbox if it has a match then it is true positive..
      if all_matches[all_matches[:, 0] == i].shape[0] == 1:
        matrix[0][0]+=1

      #if the given bbox has no match..
      #or if there are no matches based on iou then every gt bbox is FN
      #then we say that the drone is not detected hence it is FN
      else:
        matrix[0][1]+=1
    
    #enumerate for all detected bounding box..
    for i, detection in enumerate(detection_index):
      #if it is matched the we alrady have computed it in TP which running iteration for ground truth..
      #if a given bounding box has no match after filtering with IOU
      #then we say it is Detected False FP.
      if all_matches.shape[0] and all_matches[all_matches[:, 1] == i].shape[0] == 0:
        matrix[1][0]+=1

  return matrix